import * as tl from "azure-pipelines-task-lib/task";
import * as path from "path";
import { ToolRunner, IExecSyncResult } from "azure-pipelines-task-lib/toolrunner";

async function run() {
    try {
        tl.setResourcePath(path.join(__dirname, "task.json"));
        const cwd: string = tl.getPathInput("path", true, true) || __dirname;
        const level: string = tl.getInput("level", true) || "high";
        const toolPath: string = tl.which("dotnet", true);
        const toolRunner: ToolRunner = tl.tool(toolPath).arg("list").arg("package").arg("--vulnerable");

        setIncludeTransitive(toolRunner);

        tl.cd(cwd);
        const result: IExecSyncResult = toolRunner.execSync();

        const regexp: RegExp = await getLevelRegexp(level);

        const shouldBreak: boolean = regexp.test(result.stdout);

        if (shouldBreak) {
            console.log(tl.loc("VulnerabilitiesFound"));
            tl.setResult(tl.TaskResult.Failed, "Vulnerabilities found");
        }
    }
    catch (err) {
        tl.setResult(tl.TaskResult.Failed, err.message);
    }
}

function setIncludeTransitive(toolRunner: ToolRunner) {
    const includeTransitive: boolean = tl.getBoolInput("transitive", false);
    if (includeTransitive) toolRunner.arg("--include-transitive");
}

async function getLevelRegexp(level: string): Promise<RegExp> {
    if (level === "low") {
        return new RegExp(/(Low|Moderate|High|Critical)/gm);
    }
    if (level === "moderate") {
        return new RegExp(/(Moderate|High|Critical)/gm);
    }
    if (level === "high") {
        return new RegExp(/(High|Critical)/gm);
    }
    if (level === "critical") {
        return new RegExp(/Critical/gm);
    }

    throw new Error("Unexpected level");
}

run();
