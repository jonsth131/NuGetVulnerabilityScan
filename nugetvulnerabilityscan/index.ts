import * as tl from "azure-pipelines-task-lib/task";
import * as path from "path";
import { ToolRunner, IExecSyncResult } from "azure-pipelines-task-lib/toolrunner";

type ScanType = "vulnerable" | "deprecated";

async function run() {
    try {
        tl.setResourcePath(path.join(__dirname, "task.json"));
        const cwd: string = tl.getPathInput("path", true, true) || __dirname;

        const scanType: ScanType = getScanType();
        const toolRunner: ToolRunner = createToolRunner(scanType);

        tl.cd(cwd);
        const result: IExecSyncResult = toolRunner.execSync();

        handleResult(result, scanType);
    }
    catch (err: any) {
        tl.setResult(tl.TaskResult.Failed, err.message);
    }
}

function setTaskResult(message: string) {
    const emitWarning = tl.getBoolInput("warning") || false;

    if (emitWarning) {
        tl.setResult(tl.TaskResult.SucceededWithIssues, message);
    } else {
        tl.setResult(tl.TaskResult.Failed, message);
    }
}

function handleDeprecatedScanResult(result: IExecSyncResult) {
    const regexp: RegExp = new RegExp(/Project `.*` has the following deprecated packages/gm);

    if (regexp.test(result.stdout)) {
        console.log(tl.loc("DeprecatedPackagesFound"));
        setTaskResult("Deprecated packages found");
    }
}

function handleVulnerableScanResult(result: IExecSyncResult) {
    const regexp: RegExp = getLevelRegexp();

    if (regexp.test(result.stdout)) {
        console.log(tl.loc("VulnerabilitiesFound"));
        setTaskResult("Vulnerabilities found");
    }
}

function handleResult(result: IExecSyncResult, scanType: ScanType) {
    switch (scanType) {
        case "vulnerable":
            handleVulnerableScanResult(result);
            break;
        case "deprecated":
            handleDeprecatedScanResult(result);
            break;
        default:
            throw new Error("Unexpected scan type");
    }
}

function getScanType(): ScanType {
    const scanType: string = tl.getInput("type") || "vulnerable";

    switch (scanType) {
        case "vulnerable":
        case "deprecated":
            return scanType;
        default:
            throw new Error("Unexpected scan type");
    }
}

function createToolRunner(scanType: ScanType): ToolRunner {
    const toolPath: string = tl.which("dotnet", true);
    const runner: ToolRunner = tl.tool(toolPath).arg("list").arg("package");

    switch (scanType) {
        case "vulnerable":
            runner.arg("--vulnerable");
            break;
        case "deprecated":
            runner.arg("--deprecated");
            break;
    }

    const includeTransitive: boolean = tl.getBoolInput("transitive", false);
    if (includeTransitive) runner.arg("--include-transitive");

    return runner;
}

function getLevelRegexp(): RegExp {
    const level: string = tl.getInput("level") || "high";

    if (level === "low") {
        return new RegExp(/(Low|Moderate|High|Critical)/gm);
    }
    if (level === "moderate") {
        return new RegExp(/(Moderate|High|Critical)/gm);
    }
    if (level === "high") {
        return new RegExp(/(High|Critical)/gm);
    }
    if (level === "critical") {
        return new RegExp(/Critical/gm);
    }

    throw new Error("Unexpected level");
}

run();
